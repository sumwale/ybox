#!/usr/bin/python3

import os
import sys

import argparse
import getpass
import grp
import pwd
import subprocess
import shutil
import time
import typing

from configparser import SectionProxy
from pathlib import Path
from typeguard import typechecked
from zbox.env import *
from zbox.util import *

# Deliberately not using os.path.join since the code only works on Linux like
# systems where path separator will always be "/" so explicitly force the same.
# Configuration files should be in $HOME/.config/zbox or /etc/zbox.

@typechecked
def main() -> None:
    args = parse_args()
    box_name, docker_cmd = process_args(args)
    env = Environ(args, box_name)
    support_list = get_config_file("supported.list", env)
    distro = args.distribution
    # hard links are false by default
    config_hardlinks = False
    # check that the distribution is in supported.list
    with open(support_list, "r") as supp_file:
        if distro not in supp_file.read().splitlines():
            sys.exit(f"Distribution '{distro}' not supported in {support_list}")

    # the configuration file used to build the docker/podman command-line
    config_file = get_config_file(f"{distro}/confs/{args.configuration}", env)
    docker_args = [docker_cmd, "run", "-itd", f"--name={box_name}"]
    # we process the configuration file before any actions to ensure it is in proper shape
    process_sections(config_file, env, docker_args)

    # The sequence for container creation and run is thus:
    # 1) First start a basic container with smallest upstream distro image (important to save
    #    space when 'base.shared' is true) with "entrypoint-base.sh" as the entrypoint script
    #    giving user/group arguments to be same as the user as on the host machine.
    # 2) Next do a docker/podman commit and save the stopped container as local image which
    #    will be used henceforth. The main point of doing #1 is to ensure that a sudo enabled
    #    user is available which matches the current host user so that "--userns" option
    #    will not try to remap the image that can substantially increase the size of image.
    #    Either way the user created by "--userns" in the container does not have sudo
    #    permissions so we temporarily need to run such a container as root user in any case.
    #    Hence step 1 uses a cleaner and better option that also create separate
    #    container-specific images that can be enhanced with more container-specific stuff
    #    later if required.
    # 3) Start up the save image of step 2 and run the distro specific entrypoint script
    #    that will do basic configuration and package installation (e.g. git/paru/nvim on arch)
    #    followed by the generic "entrypoint.sh" script which will create the configuration
    #    file links (from [configs] section), install required apps (from [apps] section),
    #    followed by invoking the startup scripts from the [startup] section. The distro
    #    specific is run as root user (i.e. using sudo) while the generic one is run as user.
    # 4) The container is now ready to use so 'zbox-enter' will only do a docker/podman exec
    #    of /bin/bash to open a shell.
    # 5) Mounts are setup for step 3 while environment variables are set for both steps 3, 4.

    # setup entrypoint and related scripts to share with the container on a mount point
    setup_zbox_scripts(distro, env)

    # get current user and group entry, then run the container with appropriate arguments
    # to the 'entrypoint-base.sh' script to create the user in the container
    current_user = getpass.getuser()
    run_base_container(current_user, distro, docker_cmd, env)

    # commit the stopped container, remove it, then start new container with the main
    # entrypoint script along with "--userns=keep-id" and all the configured arguments
    commit_base_container(current_user, docker_cmd, env)

    # start the final container with all required arguments
    print_color(f"Initializing container using configuration from '{config_file}'",
            fg=fgcolor.purple)
    docker_short_cmd = start_container(docker_cmd, docker_args, env)

    # wait for container to initialize while printing out its progress from env.status_file
    wait_for_container(docker_cmd, docker_short_cmd, env)


@typechecked
def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", "--name", type=str,
            help="""name of the box; default is <distribution>-<configuration> if not
                    provided after trimming off .ini suffix from the <configuration>""")
    parser.add_argument("-d", "--docker-path", type=str,
            help="path of docker/podman if not in /usr/bin")
    parser.add_argument("distribution",
            help="short name of the distribution (should be in supported.list)")
    parser.add_argument("configuration",
            help="""the ini configuration file to be used for creating the zbox
                    (should be in <distribution>/confs directory)""")
    return parser.parse_args()

@typechecked
def process_args(args: argparse.Namespace) -> (str, str):
    ini_suffix = ".ini"
    if args.name:
        box_name = args.name
    else:
        box_name = args.configuration
        if box_name.endswith(ini_suffix):
            box_name = box_name[:-len(ini_suffix)]
        box_name = f"{args.distribution}-{box_name}"

    # check for podman first then docker
    if args.docker_path:
        docker_cmd = args.docker_path
    elif os.access("/usr/bin/podman", os.X_OK):
        docker_cmd = "/usr/bin/podman"
    elif os.access("/usr/bin/docker", os.X_OK):
        docker_cmd = "/usr/bin/docker"
    else:
        sys.exit("Neither /usr/bin/podman nor /usr/bin/docker found and no -d option provided")
    return box_name, docker_cmd

@typechecked
def get_config_file(f: str, env: Environ) -> str:
    for d in env.configuration_dirs:
        path = f"{d}/{f}"
        if os.access(path, os.R_OK):
            return path
    sys.exit(f"Configuration file {f} not found in [{', '.join(env.configuration_dirs)}]")


@typechecked
def process_sections(config_file: str, env: Environ, docker_args: list[str]) -> None:
    now = InitNow()
    # read the config file, recursively reading the includes if present,
    # then replace the environment variables and the special ${NOW:...} from all values
    config = config_postprocess(config_reader(config_file), now)
    # finally process all the sections and the keys forming the docker/podman command-line
    for section in config.sections():
        if section == "base":
            config_hardlinks = process_base_section(config["base"], env, docker_args)
        elif section == "security":
            process_security_section(config["security"], docker_args)
        elif section == "mounts":
            process_mounts_section(config["mounts"], docker_args)
        elif section == "env":
            process_env_section(config["env"], docker_args)
        elif section == "configs":
            process_configs_section(config["configs"], env, config_hardlinks, docker_args)
        elif section != "apps" and section != "startup":
            sys.exit(f"Unknown section [{section}] in '{config_file}' or one of its includes")

@typechecked
def process_base_section(base_section: SectionProxy, env: Environ, args: list[str]) -> bool:
    # hard links are false by default
    config_hardlinks = False
    for key in base_section:
        if key == "home":
            source_home = base_section[key]
            # create the source directory if it does not exist
            os.makedirs(source_home, exist_ok=True)
            add_mount_option(args, source_home, env.target_home)
        elif key == "config_hardlinks":
            config_hardlinks = base_section.getboolean("config_hardlinks")
        elif key == "x11":
            if base_section.getboolean("x11"):
                enable_x11(args)
        elif key == "wayland":
            if base_section.getboolean("wayland"):
                enable_wayland(args, env)
        elif key == "pulseaudio":
            if base_section.getboolean("pulseaudio"):
                enable_pulse(args, env)
        elif key == "dbus":
            if base_section.getboolean("dbus"):
                enable_dbus(args, base_section.getboolean("dbus_sys", fallback=False))
        elif key == "dri":
            if base_section.getboolean("dri"):
                args.append("--device=/dev/dri")
        elif key == "nvidia":
            if base_section.getboolean("nvidia"):
                args.append("--device=nvidia.com/gpu=all")
        elif key == "pids_limit":
            pids_limit = base_section["pids_limit"]
            if pids_limit:
                args.append(f"--pids-limit={pids_limit}")
        elif key == "log_driver":
            log_driver = base_section["log_driver"]
            if log_driver:
                args.append(f"--log-driver={log_driver}")
        elif key == "log_opts":
            add_multi_opt(args, base_section, "log_opts", "log-opt")
            # create the log directory if required
            log_dirs = [mt.group(1) for mt in
                    (re.match("^--log-opt=path=(.*)/.*$", path) for path in args) if mt]
            for log_dir in log_dirs:
                os.makedirs(log_dir, exist_ok=True)
        elif key != "includes" and key != "dbus_sys":
            sys.exit(f"Unknown key '{key}' in the [base] of {ini_file} or its includes")
    return config_hardlinks

@typechecked
def add_mount_option(args: list[str], src: str, dest: str, flags: str = "") -> None:
    if flags:
        args.append(f"-v={src}:{dest}:{flags}")
    else:
        args.append(f"-v={src}:{dest}")

@typechecked
def enable_x11(args: list[str]) -> None:
    add_env_option(args, "DISPLAY")
    xsock = "/tmp/.X11-unix"
    if os.access(xsock, os.R_OK):
        add_mount_option(args, xsock, xsock, "ro")
    if (xauth := os.environ.get("XAUTHORITY")):
        add_mount_option(args, xauth, xauth, "ro")
        add_env_option(args, "XAUTHORITY", xauth)

@typechecked
def enable_wayland(args: list[str], env: Environ) -> None:
    if (wayland_display := os.environ.get("WAYLAND_DISPLAY")):
        add_env_option(args, "WAYLAND_DISPLAY", wayland_display)
        wayland_sock = f"{env.xdg_rtdir}/{wayland_display}"
        if os.access(wayland_sock, os.W_OK):
            add_mount_option(args, wayland_sock, wayland_sock)

@typechecked
def enable_pulse(args: list[str], env: Environ) -> None:
    cookie = f"{env.home}/.config/pulse/cookie"
    if os.access(cookie, os.R_OK):
        add_mount_option(args, cookie, f"{env.target_home}/.config/pulse/cookie", "ro")
    if env.xdg_rtdir:
        pulse_native = f"{env.xdg_rtdir}/pulse/native"
        if os.access(pulse_native, os.W_OK):
            add_mount_option(args, pulse_native, pulse_native)
        for pf in [f for f in os.listdir(env.xdg_rtdir) if re.match("pipewire-[0-9]+$", f)]:
            pipewire_path = f"{env.xdg_rtdir}/{pf}"
            if os.access(pipewire_path, os.W_OK):
                add_mount_option(args, pipewire_path, pipewire_path)

@typechecked
def enable_dbus(args: list[str], sys_enable: bool) -> None:
    if (dbus_session := os.environ.get("DBUS_SESSION_BUS_ADDRESS")):
        dbus_user = dbus_session[dbus_session.find("=") + 1:]
        if (dbus_opts_idx := dbus_user.find(",")) != -1:
            dbus_user = dbus_user[:dbus_opts_idx]
        add_mount_option(args, dbus_user, dbus_user)
        add_env_option(args, "DBUS_SESSION_BUS_ADDRESS", dbus_session)
    if sys_enable:
        dbus_sys = "/run/dbus/system_bus_socket"
        dbus_sys2 = "/var/run/dbus/system_bus_socket"
        if os.access(dbus_sys, os.W_OK):
            add_mount_option(args, dbus_sys, dbus_sys)
        elif os.access(dbus_sys2, os.W_OK):
            add_mount_option(args, dbus_sys2, dbus_sys)

@typechecked
def add_multi_opt(args: list[str], section: SectionProxy, key: str, opt: str) -> None:
    if (opts := section.get(key)):
        for opt_val in opts.split(";"):
            args.append(f"--{opt}={opt_val}")

@typechecked
def process_security_section(sec_section: SectionProxy, args: list[str]) -> None:
    for key in sec_section:
        if key == "label":
            add_sec_option_if_exists(args, sec_section, "label")
        elif key == "apparmor":
            add_sec_option_if_exists(args, sec_section, "apparmor")
        elif key == "seccomp":
            add_sec_option_if_exists(args, sec_section, "seccomp")
        elif key == "seccomp_policy":
            add_option_if_exists(args, sec_section, "seccomp_policy", "seccomp-policy")
        elif key == "mask":
            add_sec_option_if_exists(args, sec_section, "mask")
        elif key == "unmask":
            add_sec_option_if_exists(args, sec_section, "unmask")
        elif key == "no_new_privileges":
            if sec_section.getboolean(key):
                args.append("--security-opt=no-new-privileges")
        elif key == "proc_opts":
            add_sec_option_if_exists(args, sec_section, "proc-opts")
        elif key == "caps_add":
            add_multi_opt(args, sec_section, "caps_add", "cap-add")
        elif key == "caps_drop":
            add_multi_opt(args, sec_section, "caps_drop", "cap-drop")
        elif key == "cgroup_parent":
            add_option_if_exists(args, sec_section, "cgroups_parent", "cgroups-parent")
        elif key == "cgroup_confs":
            add_multi_opt(args, sec_section, "cgroup_confs", "cgroup-conf")
        elif key == "cgroupns":
            add_option_if_exists(args, sec_section, "cgroupns", "cgroupns")
        elif key == "cgroups":
            add_option_if_exists(args, sec_section, "cgroups", "cgroups")
        elif key == "device_cgroup_rules":
            add_multi_opt(args, sec_section, "device_cgroup_rules", "device-cgroup-rule")
        elif key == "secrets":
            add_multi_opt(args, sec_section, "secrets", "secret")

@typechecked
def add_sec_option_if_exists(args: list[str], sec_section: SectionProxy, key: str) -> None:
    if (val := sec_section[key]):
        args.append(f"--security-opt={key}={val}")

@typechecked
def add_option_if_exists(args: list[str], section: SectionProxy, key: str, opt: str) -> None:
    if (val := section[key]):
        args.append(f"--{opt}={val}")

@typechecked
def process_mounts_section(mounts_section: SectionProxy, args: list[str]) -> None:
    for key in mounts_section:
        # keys here are only symbolic names and serve no purpose other than allowing
        # later configuration files to override previous ones
        if (val := mounts_section[key]):
            if "=" in val or "," in val:
                args.append(f"--mount={val}")
            else:
                args.append(f"-v={val}")

@typechecked
def process_configs_section(configs_section: SectionProxy, env: Environ,
        config_hardlinks: bool, args: list[str]) -> None:
    # copy or link the mentioned files in [configs] section which can be either files
    # or directories (recursively copy/link in the latter case)
    # this is refreshed on every container start

    # always recreate the directory to pick up any changes
    if os.path.exists(env.configs_dir):
        shutil.rmtree(env.configs_dir)
    os.makedirs(env.configs_dir, exist_ok=True)
    if config_hardlinks:
        print(fgcolor.blue, "Creating hard links to paths in [configs]", fgcolor.reset, sep="")
    else:
        print(fgcolor.blue, "Creating a copy of paths in [configs]", fgcolor.reset, sep="")
    for key in configs_section:
        val = configs_section[key]
        split_idx = val.find("->")
        if split_idx == -1:
            sys.exit("Incorrect value format in [configs] section for "
                    f"'{key}'. Required: '{{src}} -> {{dest}}'")
        src_path = os.path.realpath(val[:split_idx].strip())
        dest_path = f"{env.configs_dir}/{val[split_idx + 2:].strip()}"
        if os.access(src_path, os.R_OK):
            os.makedirs(os.path.dirname(dest_path), exist_ok=True)
            if os.path.isdir(src_path):
                if config_hardlinks:
                    shutil.copytree(src_path, dest_path, symlinks=False,
                            copy_function=hardlink)
                else:
                    shutil.copytree(src_path, dest_path, symlinks=False)
            else:
                if config_hardlinks:
                    hardlink(src_path, dest_path, follow_symlinks=True)
                else:
                    shutil.copy2(src_path, dest_path, follow_symlinks=True)
        else:
            print(fgcolor.red, f"Skipping inaccessible configuration path '{src_path}'",
                    fgcolor.reset, sep="")
    # finally mount the configs directory to corresponding directory in the target container
    add_mount_option(args, env.configs_dir, env.target_configs_dir, "ro")

# see this issue: os.link(..., follow_symlinks=True) broken on Linux
# https://github.com/python/cpython/issues/81793
# (the '*' in signature is from shutil.copy that indicates only keyword args allowed after it)
@typechecked
def hardlink(src: str, dst: str, *, follow_symlinks=True) -> str:
    os.link(os.path.realpath(src), dst, follow_symlinks=follow_symlinks)
    return dst

@typechecked
def setup_zbox_scripts(distro: str, env: Environ) -> None:
    # first create local mount directory having entrypoint and other scripts
    if os.path.exists(env.scripts_dir):
        shutil.rmtree(env.scripts_dir)
    os.makedirs(env.scripts_dir, exist_ok=True)
    # copy the common scripts
    for script in [env.entrypoint_base, env.entrypoint, "entrypoint-common.sh", "prime-run"]:
        path = get_config_file(f"resources/{script}", env)
        shutil.copy2(path, f"{env.scripts_dir}/{script}", follow_symlinks=True)
    # also copy distribution specific scripts
    for script in ["init-base.sh", "init.sh", "init-user.sh"]:
        path = get_config_file(f"{distro}/{script}", env)
        shutil.copy2(path, f"{env.scripts_dir}/{script}", follow_symlinks=True)

@typechecked
def run_base_container(current_user: str, distro: str, docker_cmd: str, env: Environ) -> None:
    # determine the base image name
    distro_config = config_reader(get_config_file(f"{distro}/distro.ini", env))
    image_name = distro_config["base"]["image"] # should always exist
    # get current user and group details to pass to the entrypoint script
    user_entry = pwd.getpwnam(current_user)
    group_entry = grp.getgrgid(user_entry.pw_gid)
    print_color(f"Creating container specific image having sudo user '{current_user}'",
            fg=fgcolor.purple)
    init_result = subprocess.run([docker_cmd, "run", "-it",
        f"--name={env.box_name}", f"-v={env.scripts_dir}:{env.scripts_target_dir}:ro",
        f"--entrypoint={env.scripts_target_dir}/{env.entrypoint_base}", image_name,
        "-u", current_user, "-U", str(user_entry.pw_uid), "-n", user_entry.pw_gecos,
        "-g", group_entry.gr_name, "-G", str(group_entry.gr_gid)])
    if init_result.returncode != 0:
        print_color("FAILED -- see the output above for details", fg=fgcolor.red)
        sys.exit(1)

@typechecked
def print_subprocess_output(result: subprocess.CompletedProcess) -> None:
    print_color(result.stdout.decode("utf-8"))
    print_color(result.stderr.decode("utf-8"), fg=fgcolor.orange)

@typechecked
def commit_base_container(current_user: str, docker_cmd: str, env: Environ) -> None:
    commit_result = subprocess.run([docker_cmd, "commit", f"-c=USER={current_user}",
        f"-c=WORKDIR=/home/{current_user}", env.box_name, env.box_image], capture_output=True)
    if commit_result.returncode != 0:
        print_subprocess_output(commit_result)
        print_color("FAILED in container commit -- see the output above for details",
                fg=fgcolor.red)
        sys.exit(1)

    remove_result = subprocess.run([docker_cmd, "container", "rm", env.box_name])
    if remove_result.returncode != 0:
        print_color("FAILED in container rm -- see the output above for details",
                fg=fgcolor.red)
        sys.exit(1)

@typechecked
def start_container(docker_cmd: str, docker_args: list[str], env: Environ) -> str:
    add_mount_option(docker_args, env.scripts_dir, env.scripts_target_dir, "ro")
    # touch the status file and mount it
    status_path = Path(env.status_file)
    status_path.unlink(missing_ok=True)
    status_path.touch(mode=0o600, exist_ok=False)
    add_mount_option(docker_args, env.status_file, env.status_target_file)

    docker_args.append(f"--entrypoint={env.scripts_target_dir}/{env.entrypoint}")
    docker_args.append("--userns=keep-id")
    docker_args.append(env.box_image)
    docker_args.append(env.box_name)
    docker_short_cmd = os.path.basename(docker_cmd)
    launch_result = subprocess.run(docker_args)
    if launch_result.returncode != 0:
        print_color("FAILED to launch container -- see the output above and check "
                f"'{docker_short_cmd} logs {env.box_name}' for details", fg=fgcolor.red)
        sys.exit(1)
    return docker_short_cmd

@typechecked
def wait_for_container(docker_cmd: str, docker_short_cmd: str, env: Environ) -> None:
    box_name = env.box_name
    print_color("Waiting for container to be ready (see "
            f"'{docker_short_cmd} logs -f {box_name}' for detailed progress)", fg=fgcolor.blue)
    sys.stdout.flush()
    max_wait_secs = 600
    with open(env.status_file, "r", encoding="utf-8") as status_fd:
        for secs in range(max_wait_secs):
            # check the container status first
            check_result = subprocess.run([docker_cmd, "inspect", "-f",
                "{{.State.Status}}", box_name], capture_output=True)
            if (check_result.returncode == 0 and
                    check_result.stdout.decode("utf-8").startswith("running")):
                while line := status_fd.readline():
                    if line == "started\n":
                        return
                    print(line, end="") # line already includes the terminating newline
            else:
                with open(env.status_file, "a") as status_fd:
                    status_fd.truncate(0)
                print_color("FAILED waiting for container to be ready -- check "
                        f"'{docker_short_cmd} logs {box_name}' for details", fg=fgcolor.red)
                sys.exit(1)
            # using simple poll per second rather than inotify or similar because the
            # initialization will take a good amount of time and second granularity is enough
            time.sleep(1)
    # reading did not end after max_wait_secs
    print_color(f"TIMED OUT waiting for ready container after {max_wait_secs}secs -- check "
            f"'{docker_short_cmd} logs -f {box_name}' for details", fg=fgcolor.red)
    sys.exit(1)


main()
