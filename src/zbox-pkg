#!/usr/bin/python3

import argparse
import subprocess
import sys
from configparser import SectionProxy

from zbox.config import ZboxConfiguration
from zbox.env import Environ
from zbox.state import ZboxStateManagement
from zbox.util import EnvInterpolation, PkgMgr, ZboxLabel, config_reader
from zbox.util import get_docker_command, print_error, print_info, run_command, verify_zbox_state


def main() -> int:
    args = parse_args()
    docker_cmd = get_docker_command(args, "-d")
    container_name = args.zbox

    if not container_name:
        # check running containers
        containers = run_command([docker_cmd, "container", "ls", "--format={{ .Names }}",
                                  f"--filter=label={ZboxLabel.CONTAINER_PRIMARY}"],
                                 capture_output=True, error_msg="container ls").splitlines()
        if args.quiet:
            # use running container if there is only one of them
            if len(containers) == 1:
                container_name = containers[0]
            else:
                print_error(f"Expected one active zbox container but found {len(containers)}")
                return 1
        else:
            container_msg = ""
            if len(containers) > 0:
                container_msg = f" among [{containers[0]}] {' '.join(containers[1:])}"
            while not container_name:
                container_name = input(f"Please provide the container to use{container_msg}: ")
                if not container_name and len(containers) > 0:
                    container_name = containers[0]

    verify_zbox_state(docker_cmd, container_name, ["running"], error_msg=" active ")

    env = Environ()
    with ZboxStateManagement(env) as state:
        if (config := state.get_container_configuration(container_name)) is None:
            print_error(f"No state for zbox container '{container_name}' found!")
            return 1
        conf = ZboxConfiguration(env, config[0], container_name)
        env_interpolation = EnvInterpolation(env, [])
        distro_config = config_reader(conf.get_config_file(f"{conf.distribution}/distro.ini"),
                                      env_interpolation)
        pkgmgr = distro_config["pkgmgr"]
        return args.func(args, pkgmgr, docker_cmd, container_name)


def install_package(args: argparse.Namespace, pkgmgr: SectionProxy, docker_cmd: str,
                    container_name: str) -> int:
    print_info(f"Installing '{args.package}' in '{container_name}'")
    quiet_flag = pkgmgr[PkgMgr.QUIET_FLAG.name] if args.quiet else ""
    install_cmd = pkgmgr[PkgMgr.INSTALL.name].format(quiet=quiet_flag)
    # don't exit on error here because the caller may have further actions to perform before exit
    code = run_command([docker_cmd, "exec", "-it", container_name, "/bin/bash", "-c",
                        f"{install_cmd} {args.package}"], exit_on_error=False,
                       error_msg=f"installing '{args.package}'")
    # TODO: register in the state
    if args.opt_deps:
        # find the optional dependencies recursively, removing the ones already installed and
        # ask the user to choose the ones to install
        opt_deps_cmd = pkgmgr[PkgMgr.OPT_DEPS.name]
        deps_result = subprocess.run([docker_cmd, "exec", "-it", container_name, "/bin/bash",
                                      "-c", f"{opt_deps_cmd} {args.package}"], check=False)
        # expected format of output of above is -- PKG: <name>::::<description>::::<level>
        if deps_result.returncode != 0:
            print_error(f"FAILED to determine optional dependencies of {args.package} -- "
                        "see above output for details")

    return int(code)


def uninstall_package(args: argparse.Namespace, pkgmgr: SectionProxy, docker_cmd: str,
                      container_name: str) -> int:
    print(f"SW: Will uninstall {args.package} in {container_name} using {docker_cmd}")
    return 0


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Package management across zbox containers")
    operations = parser.add_subparsers(title="Operations", required=True, metavar="OPERATION",
                                       help="DESCRIPTION")
    add_install(operations.add_parser("install", help="install a package with dependencies"))
    add_uninstall(operations.add_parser("uninstall", help="uninstall a package and "
                                                          "optionally its dependencies"))
    # parser.add_argument("operation", type=str,
    #                    choices=("install", "uninstall", "update", "list", "info", "search",
    #                             "mark", "clean", "repair"),
    #                    help="the package operation to perform")
    return parser.parse_args()


def add_common_args(subparser: argparse.ArgumentParser) -> None:
    subparser.add_argument("-d", "--docker-path", type=str,
                           help="path of docker/podman if not in /usr/bin")
    subparser.add_argument("-z", "--zbox", type=str,
                           help="the zbox container to use for package operations")
    subparser.add_argument("-q", "--quiet", action="store_true",
                           help="proceed without asking any questions")


def add_install(subparser: argparse.ArgumentParser) -> None:
    add_common_args(subparser)
    subparser.add_argument("-o", "--opt-deps", type=str,
                           help="install optional dependencies (or recommendations)")
    subparser.add_argument("package", type=str, help="the package to install")
    subparser.set_defaults(func=install_package)


def add_uninstall(subparser: argparse.ArgumentParser) -> None:
    add_common_args(subparser)
    subparser.add_argument("-p", "--purge", type=str,
                           help="remove everything including system configuration files "
                                "of the package")
    subparser.add_argument("-r", "--remove-deps", type=str,
                           help="uninstall unused dependencies in addition to the package")
    subparser.add_argument("package", type=str, help="the package to uninstall")
    subparser.set_defaults(func=uninstall_package)


sys.exit(main())
