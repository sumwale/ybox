# Configuration file for podman/docker containers used by ybox scripts.
# This is the common file included by all other configurations.
#
# Value format is as supported by python ConfigParser
# (e.g. https://docs.python.org/3/library/configparser.html for Python3 docs).
# Specifically boolean values are extracted using getboolean() method which supports
# many different values like on/off, true/false etc.
# Key-value separator can only be '=' while ':' is not supported. Default basic value
# interpolation implemented by the python module has been extended to also support environment
# variables as described next.
#
# The values can contain environment variables using the notation supported by
# python expandvars (https://docs.python.org/3/library/os.path.html#os.path.expandvars).
# A few special environment variables are also available:
#   - YBOX_DISTRIBUTION_NAME: name of the Linux distribution (as provided to 'ybox-create')
#   - YBOX_CONTAINER_NAME: name of the current container (as provided/set by 'ybox-create')
#   - YBOX_CONTAINER_DIR: set to $HOME/.local/share/ybox/$YBOX_CONTAINER_NAME for convenience
#   - YBOX_TARGET_SCRIPTS_DIR: local directory in the container where various ybox scripts
#                              are mounted (e.g. entrypoint scripts)
#   - YBOX_SYS_CONF_DIR: path to system configuration directory where configuration directory
#                        shipped with ybox is installed (or the string form of
#                          the directory if it is not on filesystem like an egg or similar)
#   - TARGET_HOME: set to the home directory of the container user
# Additionally a special notation can be used for current date+time with this notation:
#   ${NOW:<fmt>}. The <fmt> uses the format supported by python strftime
# (https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime)
# while the NOW is the result of datetime.now() call.
#
# Expansion of other keys in the same section or the special 'DEFAULT' section is also provided
# using the notation supported by python's configparser BasicInterpolation, see:
# https://docs.python.org/3/library/configparser.html#configparser.BasicInterpolation
# In a nutshell you need '%(<var>)s' notation to expand <var> key and bare '%' should be '%%'.
# However, the '%' inside the ${NOW:<fmt>} format should not be escaped because all environment
# variables as well as ${NOW:...} are expanded before the variable references.
#
# NOTE: Take care to have different path settings point to distinct directory/path
# locations e.g. base.shared_root, base.home and base.log_opts.path (podman) should point to
# different directories else you can lose one or the other since the code currently does not
# check for such overlaps and will happily mount the directory as the container home while
# logs are also being written there which can result in an unpredictable behavior.
# Likewise the configuration files in [configs] section are temporarily copied/linked in
# $YBOX_CONTAINER_DIR/configs which is not configurable and should not be used and there
# is a temporary mount directory having utility scripts in $YBOX_CONTAINER_DIR/ybox-scripts


# Basic container settings that are documented individually below.
[base]
# A short description of this profile.
name = Basic profile for CLI and most GUI apps
# Comma separated files to include before applying these settings.
# Paths can be absolute or relative to the location of this file.
includes =
# Whether the system directories are shared between all containers of the same distribution
# is determined by this variable. The common system directories are bind mounted to a common
# host directory specified by this `shared_root` variable.
#
# It includes all directories (defined in distro.ini) that hold system package data which
# also means that the packages installed on one container are visible on all the containers
# of the same distribution. So those packages can be launched from any of the containers
# but they will be subject to that container configuration. The wrapper launcher scripts
# created by `ybox-pkg install` will ensure that packages are launched only from the containers
# where they were installed so that should be the preferred way to launch apps (except for
#   packages common to multiple containers which can be launched from any of those).
#
# Default is enabled so as to save space, page cache space etc, and allow users
# to freely create as many containers as desired to achieve best isolation without worrying
# about dramatic increase in disk and/or memory usage.
shared_root = $HOME/.local/share/ybox/SHARED_ROOTS/$YBOX_DISTRIBUTION_NAME
# Bind mount the container $HOME to this local path (aka $TARGET_HOME). This makes it
# easier for backup software and otherwise to read useful container data.
# If not provided then you should explicitly mount required directories in the [mounts]
# section otherwise home will remain completely ephemeral which is not recommended.
home = $YBOX_CONTAINER_DIR/home
# Whether the configuration files (specified in [configs] section) should be hard linked
#    to a temporary directory that is made available to the container, or copied over.
# Hardlinks will not work if you have mounted the temporary directory inside
# ~/.local/share/ybox on a separate volume other than home itself.
# Directories are hard linked recursively and symlinks in the source are followed to their
# destination which must again exist on the same filesystem.
#
# In case of hardlinks, any changes made on host will be immediately visible otherwise
# with this as false, you need to re-create the container to let it see any changes.
# You can also use this for only first time reference and then make a separate copy
# inside the container which will break any direct sharing between the host and container.
#
# An empty value will cause [configs] section to be completely skipped.
config_hardlinks = true
# If enabled, then locale in the container will be configured as per the LANG and LANGUAGE
# environment variables from the host environment.
config_locale = true
# If enabled then X server from the user session is available to the container.
x11 = on
# If enabled then Wayland server from the user session is available to the container.
wayland = on
# If enabled then pulseaudio/pipewire from the user session is available to the container.
# This will enable either of pulse/pipewire (or both) whichever is available on the host.
pulseaudio = on
# If enabled then dbus from the user session is available to the container.
dbus = on
# If enabled then the system dbus from the host is available to the container.
dbus_sys = off
# If enabled then Direct Rendering Infrastructure for accelerated graphics is available to
# the container.
dri = on
# If enabled then NVIDIA GPUs will be accessible in the container by making available NVIDIA
# devices, libraries and binaries from the host system to the container. The search for
# NVIDIA on the host should work on most modern Linux distributions, but if does not then
# install NVIDIA container toolkit and use the "nvidia_ctk" option below.
#
# This option should be preferred over "nvidia_ctk" option because it can handle NVIDIA
# driver updates transparently without reconfiguration and does not need additional installation.
nvidia = off
# If enabled then NVIDIA GPUs will be available to the container. You need to install
# NVIDIA container toolkit for this to work. Refer to Arch wiki for details which usually
# works well on most Linux distros (https://wiki.archlinux.org/title/docker or
#    https://wiki.archlinux.org/title/podman), and the official NVIDIA docs:
#  https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html
# For example on ubuntu with podman, configure the apt repository from the previous link
# and install the package as noted there, then run
# `sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml`.
# This will need to be repeated if nvidia driver version is upgraded.
#
# This will take precedence if both "nvidia" and "nvidia_ctk" are enabled.
nvidia_ctk = off
# default podman/docker shm-size is 64m which can be insufficient for many apps
shm_size = 1g
# Limit the maximum number of processes in the container (to avoid stuff like fork bombs).
pids_limit = 2048
# Logging driver to use. Default for podman/docker is to use journald in modern Linux
# distributions which pollutes the journald logs.
# Note that on podman, json-file is an alias for k8s-file which produces plaintext format.
log_driver = json-file
# Comma separated options for the logger.
# Example of path with timestamped file for podman
#log_opts = path=$YBOX_CONTAINER_DIR/logs/${NOW:%Y-%m-%d_%H.%M.%S}.log,max-size=10m,max-file=3
# Example for docker that does not support `path`
log_opts = max-size=10m,max-file=3


# The security-opt and other security options passed to podman/docker.
# You should restrict these as required.
# If these have to be relaxed for some apps, then it is highly recommended to put
# those in their own separate containers having minimal or no access to original home
# directories to isolate them as much as possible. Do read up on security implications
# before relaxing these.
# See docs like https://docs.docker.com/engine/security/seccomp,
# https://docs.docker.com/engine/security/apparmor,
# https://docs.podman.io/en/latest/markdown/podman-run.1.html etc
# The following keys are available -- not all of these may be supported by the available
#     podman/docker installation but are passed as is, so they can throw an error:
#   label: corresponding to --security-opt=label=...
#   apparmor: --security-opt=apparmor=...
#   seccomp: --security-opt=seccomp=...
#   mask: --security-opt=mask=...
#   unmask: --security-opt=unmask=...
#   no_new_privileges: boolean to enable --security-opt=no-new-privileges
#   proc_opts: --security-opt=proc-opts=...
#   seccomp_policy: --seccomp-policy=...
#   caps_add: comma separated multiple --cap-add=... options
#   caps_drop: comma separated multiple --cap-drop=... options
#   ulimits: comma separated multiple --ulimit=... options
#   ipc: --ipc=...
#   cgroup_parent: --cgroup-parent=...
#   cgroup_confs: comma separated multiple --cgroup-conf=... options
#   cgroupns: --cgroupns=...
#   cgroups: --cgroups=...
#   device_cgroup_rules: comma separated multiple --device-cgroup-rule=... options
#   secrets: comma separated multiple --secret=... options
[security]
# The options are sent as is to podman/docker e.g. "label=type:container_runtime_t"
# (the default "container_runtime_t" label bypasses some selinux restrictions)
label = type:container_runtime_t
# arch pacman may need this but seems to be working fine without it even with the warnings
#caps_add = SYS_CHROOT
# --ulimit=host is only available for podman which copies host ulimits by default
# ulimits = host
# default is private IPC
# WARNING: setting this to 'host' can open a major security attack vector
ipc = private


# These are podman/docker volumes that can use either the format of --mount or -v options
# (the scripts make a quick guess by searching for = or ,).
# These will typically include some directories from your home like Downloads.
[mounts]
# Share terminfo definitions which may be missing for some terminals in the container.
terminfo = /usr/share/terminfo:/var/lib/terminfo:ro
# Downloads is configured to share data with original session easily so it should not
# contain "unsharable" stuff.
downloads = $HOME/Downloads:$TARGET_HOME/Downloads
# Documents is shared in read-only mode
documents = $HOME/Documents:$TARGET_HOME/Documents:ro
# might be required for some apps if NVIDIA is enabled
# video_dev = /dev/video0:/dev/video0


# These can be used to specify the configuration files from the host session
# that you want to share with the container. The files from the host session
# will either be copied or hard linked (depending on the "config_hardlinks" option in [base]
#   section) to a directory that is mounted read-only.
#
# The value has two parts separated by "->" with the LHS of this being the source that
# is to be copied while the RHS is the required relative path in the target directory.
# On the target container the same is used to symlink from the target on RHS to source on LHS.
# Source is skipped if it does not exist or not readable with a message on standard output.
#
# Typically this will contain shell, vim and other common configuration files.
# These can be either files or directories and are skipped if they do not exist.
# The keys here have no special significance other than the fact that they should be
# unique and can be used to override in later files that include this one.
#
# Note: The files are symlinks in the container user area and are mounted on a read-only
# mount by default, so if you need to change a file within a container then you will
# need to first remove the symlink and make a copy of the file. This will remove the
# direct sharing between the two which has to be done manually thereon if required.
# The sharing behavior also depends on "config_hardlinks" as described in its comment above
# in the [base] section.
#
# Note: The HOME environment variable here will be evaluated both in the host
# session (for the source to be transferred) and inside the container session
# (for the target). Do not use TARGET_HOME here which can be incorrect for the host session.
[configs]
bashrc = $HOME/.bashrc -> .bashrc
starship = $HOME/.config/starship.toml -> .config/starship.toml
fishrc = $HOME/.config/fish -> .config/fish
omf = $HOME/.config/omf -> .config/omf
omf_data = $HOME/.local/share/omf -> .local/share/omf
zshrc = $HOME/.zshrc -> .zshrc
zsh_p10 = $HOME/.p10k.zsh -> .p10k.zsh
dir_colors = $HOME/.dir_colors -> .dir_colors
vimrc = $HOME/.vimrc -> .vimrc
nvimrc = $HOME/.config/nvim -> .config/nvim
themes = $HOME/.themes -> .themes
cursors = $HOME/.icons -> .icons
icons = $HOME/.local/share/icons -> .local/share/icons
pipconf = $HOME/.config/pip/pip.conf -> .config/pip/pip.conf
gitconf = $HOME/.gitconfig -> .gitconfig
gtk2rc = $HOME/.gtkrc-2.0 -> .gtkrc-2.0
gtk3rc = $HOME/.config/gtk-3.0 -> .config/gtk-3.0
gtk4rc = $HOME/.config/gtk-4.0 -> .config/gtk-4.0
qt5conf = $HOME/.config/Trolltech.conf -> .config/Trolltech.conf
qt5ctconf = $HOME/.config/qt5ct/qt5ct.conf -> .config/qt5ct/qt5ct.conf
ariaconf = $HOME/.config/aria2/aria2.conf -> .config/aria2/aria2.conf
speechconf = $HOME/.config/speech-dispatcher -> .config/speech-dispatcher


# Environment variables set for the container using invoking podman/docker environment.
# Environment variables in values can be specified like usual which are expanded by
# python expandvars as usual.
#
# X, pulse and other such environment variables are set automatically by the settings
# in the [base] section but one can override/add to them explicitly here if required.
#
# Keys without values can be specified which are sent as such to the "-e" option
# which means they will be set and passed if set in the invoking podman/docker environment.
#
# Special note on LD_LIBRARY_PATH: the "nvidia=on" directive in the [base] section sets up
# LD_LIBRARY_PATH to point to internally created NVIDIA library directories shared from
# the host environment. So explicitly setting LD_LIBRARY_PATH below will break NVIDIA
# unless one also figures out and adds the internally added paths to LD_LIBRARY_PATH.
[env]
TERM
TERMINFO_DIRS = /usr/share/terminfo:/var/lib/terminfo
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_SESSION_TYPE
DESKTOP_SESSION
GTK_IM_MODULE
QT_IM_MODULE
SDL_IM_MODULE
XMODIFIERS


# Additional apps to be installed in the container. Note that these are installed
# on first container startup and will go away if the container is removed, so you
# should keep persistent data related to apps on separate persistent storage
# specified in the [mounts] section above.
[apps]
# The format is a unique name followed by comma separated package names of the distro
# specific packages. The package name may have a ':dep(<pkg>)' suffix that indicates it is being
# installed as an optional dependency of another package which is mentioned in the parentheses.
# For example (package names are from pacman) -- also notice multiline value for 'firefox_deps':
#firefox = firefox
#firefox_deps = hunspell-en_us:dep(firefox),libnotify:dep(firefox),
#               speech-dispatcher:dep(firefox)


# Default flags can be added to specified programs when launching them via their wrapper
# desktop files or wrapper executables
[app_flags]
# These flags/arguments will be added to Exec line of chromium.desktop when it is copied to
# host as well as in the wrapper chromium executable created on the host.
# You can use "!p" here for the first argument in the 'Exec='/'TryExec=' line in the desktop
# file and '!a' for rest of the arguments. When linking to an executable program, '!p' will
# refer to the full path of the executable while '!a' will be replaced by "$@" in the shell
# script. Use '!!p' for a literal '!p' and '!!a' for a literal '!a'.

# /dev/shm usage is disabled for chromium because that requires ipc=host or mounting host
# /dev/shm in read-write mode which is quite insecure.
chromium = !p --disable-dev-shm-usage --enable-chrome-browser-cloud-management !a


# Startup programs you want to run when starting the container. These are run using
# /bin/bash shell of the container, so you can use shell variables if required.
# These programs are run as normal container user, so if you need to run using root
# account then add 'sudo' before the command.
[startup]
# for example you can avoid sharing dbus of the original session rather start a separate one
#dbus = /usr/bin/dbus-daemon --session
#dbus_sys = sudo /usr/bin/dbus-daemon --system
